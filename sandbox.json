import React, { useEffect, useMemo, useRef, useState } from "react";
import { FormRenderer } from "src/form";

const presets = [
  {
    id: "everything",
    label: "Everything (2 fields + validations)",
    json: {
      title: "Everything",
      checkErrorsMode: "onValueChanged",
      elements: [
        {
          type: "text",
          name: "type_text",
          title: "type=text (required + length + regex)",
          placeholder: "Only letters, 2-12 chars",
          isRequired: true,
          requiredErrorText: "This field is required",
          validators: [
            { type: "text", minLength: 2, maxLength: 12, text: "2-12 chars" },
            { type: "regex", regex: "^[A-Za-z]+$", text: "Letters only" },
          ],
        },
        {
          type: "dropdown",
          name: "type_dropdown",
          title: "type=dropdown (required)",
          isRequired: true,
          choices: [
            { value: "a", text: "Option A" },
            { value: "b", text: "Option B" },
            { value: "c", text: "Option C" },
          ],
        },
      ],
    },
  },
  {
    id: "types",
    label: "Types showcase (all components)",
    json: {
      title: "Types showcase",
      checkErrorsMode: "onValueChanged",
      elements: [
        { type: "text", name: "t_text", title: "type=text", placeholder: "Text" },
        { type: "text", name: "t_email", title: "type=text (inputType=email)", inputType: "email", placeholder: "a@b.com" },
        { type: "text", name: "t_date", title: "type=text (inputType=date)", inputType: "date" },
        { type: "text", name: "t_datetime", title: "type=text (inputType=datetime-local)", inputType: "datetime-local" },
        { type: "comment", name: "t_comment", title: "type=comment", rows: 3, placeholder: "Multiline..." },
        { type: "boolean", name: "t_boolean", title: "type=boolean", labelTrue: "True", labelFalse: "False" },
        { type: "radiogroup", name: "t_radio", title: "type=radiogroup", choices: ["A", "B", "C"] },
        { type: "dropdown", name: "t_dropdown", title: "type=dropdown", allowClear: true, choices: ["PL", "DE", "US"] },
        { type: "checkbox", name: "t_checkbox", title: "type=checkbox", choices: ["x", "y", "z"] },
        { type: "tagbox", name: "t_tagbox", title: "type=tagbox", allowMultiple: true, storeDataAsText: true, choices: ["react", "schema", "ui"] },
        { type: "file", name: "t_file", title: "type=file", acceptedTypes: ".png,.jpg,.pdf", maxSize: 5_000_000 },
        { type: "expression", name: "t_expr", title: "type=expression", expression: "'Hello ' + {t_text}", displayStyle: "none" },
        {
          type: "multipletext",
          name: "t_multipletext",
          title: "type=multipletext",
          items: [
            { name: "a", title: "item a (text)", inputType: "text" },
            { name: "b", title: "item b (number)", inputType: "number" },
          ],
        },
        {
          type: "panel",
          name: "t_panel",
          title: "type=panel",
          renderAs: "Card",
          elements: [{ type: "text", name: "t_panel_text", title: "child: type=text" }],
        },
      ],
    },
  },
];

const safeStringify = (v) => {
  try {
    return JSON.stringify(v, null, 2);
  } catch {
    return String(v);
  }
};

const tryParse = (t) => {
  try {
    return { ok: true, value: JSON.parse(t), error: "" };
  } catch (e) {
    return { ok: false, value: null, error: e instanceof Error ? e.message : String(e) };
  }
};

export default function Sandbox() {
  const [presetId, setPresetId] = useState(presets[0].id);
  const [text, setText] = useState(() => safeStringify(presets[0].json));
  const [json, setJson] = useState(presets[0].json);
  const [parseError, setParseError] = useState("");
  const [result, setResult] = useState({});
  const [formErrors, setFormErrors] = useState(null);

  const textareaRef = useRef(null);

  const preset = useMemo(() => presets.find((p) => p.id === presetId) ?? presets[0], [presetId]);

  useEffect(() => {
    setText(safeStringify(preset.json));
    setJson(preset.json);
    setParseError("");
    setResult({});
    setFormErrors(null);
  }, [preset]);

  useEffect(() => {
    const t = setTimeout(() => {
      const parsed = tryParse(text);
      setParseError(parsed.ok ? "" : parsed.error);
      if (parsed.ok) setJson(parsed.value);
    }, 150);
    return () => clearTimeout(t);
  }, [text]);

  const format = () => {
    const parsed = tryParse(text);
    if (!parsed.ok) return;
    setText(safeStringify(parsed.value));
    requestAnimationFrame(() => textareaRef.current?.focus?.());
  };

  return (
    <div style={{ height: "100vh", display: "flex", flexDirection: "column" }}>
      <div style={{ padding: 10, borderBottom: "1px solid #ddd", display: "flex", gap: 8, alignItems: "center" }}>
        <div style={{ fontWeight: 700 }}>Schema Sandbox</div>

        <select value={presetId} onChange={(e) => setPresetId(e.target.value)} style={{ marginLeft: 10 }}>
          {presets.map((p) => (
            <option key={p.id} value={p.id}>
              {p.label}
            </option>
          ))}
        </select>

        <button onClick={format} style={{ marginLeft: "auto" }}>
          Format JSON
        </button>
      </div>

      <div style={{ flex: 1, display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", minHeight: 0 }}>
        {/* 1) JSON */}
        <div style={{ borderRight: "1px solid #ddd", padding: 10, minHeight: 0, display: "flex", flexDirection: "column" }}>
          <div style={{ fontWeight: 700, marginBottom: 8 }}>JSON</div>
          <textarea
            ref={textareaRef}
            value={text}
            onChange={(e) => setText(e.target.value)}
            spellCheck={false}
            style={{ flex: 1, width: "100%", resize: "none" }}
          />
          {parseError ? (
            <div style={{ marginTop: 8, color: "#b00020", whiteSpace: "pre-wrap" }}>{parseError}</div>
          ) : null}
        </div>

        {/* 2) Render */}
        <div style={{ borderRight: "1px solid #ddd", padding: 10, minHeight: 0, overflow: "auto" }}>
          <div style={{ fontWeight: 700, marginBottom: 8 }}>Render</div>

          {!parseError ? (
            <FormRenderer
              json={json}
              // jeśli FormRenderer wspiera callbacki - wynik pokaże się w 4. kolumnie;
              // jeśli nie, to nic nie popsuje (nadmiarowe propsy będą zignorowane).
              onChange={(next) => setResult(next ?? {})}
              onResultChange={(next) => setResult(next ?? {})}
              onErrorsChange={(errs) => setFormErrors(errs ?? null)}
            />
          ) : (
            <div>Fix JSON to render.</div>
          )}
        </div>

        {/* 3) Notes */}
        <div style={{ borderRight: "1px solid #ddd", padding: 10, minHeight: 0, overflow: "auto" }}>
          <div style={{ fontWeight: 700, marginBottom: 8 }}>Notes</div>
          <div style={{ fontSize: 13, lineHeight: 1.35 }}>
            <div style={{ marginBottom: 10 }}>
              Preset <b>Everything</b> ma tylko <b>type=text</b> i <b>type=dropdown</b> + walidacje.
            </div>
            <div style={{ marginBottom: 10 }}>
              Preset <b>Types showcase</b> pokazuje wszystkie typy komponentów.
            </div>
            <div style={{ marginBottom: 10 }}>
              Edytuj JSON po lewej i obserwuj render oraz wynik po prawej.
            </div>
            <div style={{ fontSize: 12, color: "#666" }}>
              Jeśli wynik w 4. kolumnie się nie zmienia, to znaczy że Twój <code>FormRenderer</code> nie emituje callbacków
              (<code>onChange</code>/<code>onResultChange</code>). Wtedy trzeba dodać taki callback w implementacji.
            </div>
          </div>
        </div>

        {/* 4) Result */}
        <div style={{ padding: 10, minHeight: 0, overflow: "auto" }}>
          <div style={{ fontWeight: 700, marginBottom: 8 }}>Result</div>
          {formErrors ? (
            <div style={{ marginBottom: 8, color: "#b00020" }}>{safeStringify(formErrors)}</div>
          ) : null}
          <pre style={{ margin: 0, whiteSpace: "pre-wrap" }}>{safeStringify(result)}</pre>
        </div>
      </div>
    </div>
  );
}
